# -*- coding: utf-8 -*-
"""
Copyright (c) 2015 Jesse Peterson, 2017 Mosen
Licensed under the MIT license. See the included LICENSE.txt file for details.

Attributes:
    db (SQLAlchemy): A reference to flask SQLAlchemy extensions db instance.
"""
from flask_sqlalchemy import SQLAlchemy

import datetime
from enum import Enum, IntEnum
from sqlalchemy.ext.mutable import MutableDict
from sqlalchemy.ext.hybrid import hybrid_property
from .mutablelist import MutableList
from .dbtypes import GUID, JSONEncodedDict
from .mdm import CommandStatus, Platform, commands
import base64
from binascii import hexlify
from biplist import Data as NSData
from .profiles.certificates import KeyUsage


db = SQLAlchemy()


class CertificateType(Enum):
    """A list of the polymorphic identities available for subclasses of Certificate."""
    CSR = 'csr'
    PUSH = 'mdm.pushcert'
    WEB = 'mdm.webcrt'
    CA = 'mdm.cacert'
    DEVICE = 'mdm.device'


class Certificate(db.Model):
    """Polymorphic base for certificate types.
    
    These certificate classes are only intended to be used for storing certificates related to running the MDM or
    certificates issued by the MDM internal CA or SCEP service.
    
    Note that X.509 name attributes have fixed lengths as defined in `RFC5280`_. 
    
    :table: certificates
           
    .. _RFC5280:
       http://www.ietf.org/rfc/rfc5280.txt 
    """
    __tablename__ = 'certificates'

    id = db.Column(db.Integer, primary_key=True)
    """id (int): Primary Key"""
    pem_data = db.Column(db.Text, nullable=False)
    """pem_data (str): PEM Encoded Certificate Data"""
    rsa_private_key_id = db.Column(db.Integer, db.ForeignKey('rsa_private_keys.id'))
    """rsa_private_key_id (int): Foreign key reference to an RSAPrivateKey IF the private key was generated by us."""
    x509_cn = db.Column(db.String(64), nullable=True)
    """x509_cn (str): X.509 Common Name"""
    x509_ou = db.Column(db.String(32))
    """x509_ou (str): X.509 Organizational Unit"""
    x509_o = db.Column(db.String(64))
    """x509_o (str): X.509 Organization"""
    x509_c = db.Column(db.String(2))
    """x509_c (str): X.509 2 letter Country Code"""
    x509_st = db.Column(db.String(128))
    """x509_st (str): X.509 State or Location"""
    not_before = db.Column(db.DateTime(timezone=False), nullable=False)
    """not_before (datetime): Certificate validity - not before"""
    not_after = db.Column(db.DateTime(timezone=False), nullable=False)
    """not_after (datetime): Certificate validity - not after"""
    # SHA-256 hash of DER-encoded certificate
    fingerprint = db.Column(db.String(64), nullable=False, index=True, unique=True)  # Unique
    """fingerprint (str): SHA-256 hash of certificate"""
    push_topic = db.Column(db.String, nullable=True)  # Only required for push certificate
    """push_topic (str): Only present for Push Certificates, the x.509 User ID field value"""
    discriminator = db.Column(db.String(20))
    """discriminator (str): The type of certificate"""

    __mapper_args__ = {
        'polymorphic_on': discriminator,
        'polymorphic_identity': 'certificates',
    }


class RSAPrivateKey(db.Model):
    """RSA Private Key Model"""
    __tablename__ = 'rsa_private_keys'

    #: id db.Column
    id = db.Column(db.Integer, primary_key=True)
    pem_data = db.Column(db.Text, nullable=False)

    certificates = db.relationship(
        'Certificate',
        backref='rsa_private_key',
        lazy='dynamic'
    )


class CertificateSigningRequest(Certificate):
    """Polymorphic single table inheritance specifically for Certificate Signing Requests."""
    __mapper_args__ = {
        'polymorphic_identity': CertificateType.CSR.value
    }


class SSLCertificate(Certificate):
    """Polymorphic single table inheritance specifically for SSL certificates assigned to the MDM for HTTPS traffic."""
    __mapper_args__ = {
        'polymorphic_identity': CertificateType.WEB.value
    }


class PushCertificate(Certificate):
    """Polymorphic single table inheritance specifically for APNS MDM Push Certificates assigned to the MDM."""
    __mapper_args__ = {
        'polymorphic_identity': CertificateType.PUSH.value
    }


class CACertificate(Certificate):
    """Polymorphic single table inheritance specifically for Certificate Authorities generated by this MDM."""
    __mapper_args__ = {
        'polymorphic_identity': CertificateType.CA.value
    }


class DeviceIdentityCertificate(Certificate):
    """Polymorphic single table inheritance specifically for device identity certificates."""
    __mapper_args__ = {
        'polymorphic_identity': CertificateType.DEVICE.value
    }


class CellularTechnology(IntEnum):
    Nothing = 0
    GSM = 1
    CDMA = 2
    Both = 3


device_tags = db.Table('device_tags', db.metadata,
                    db.Column('device_id', db.Integer, db.ForeignKey('devices.id')),
                    db.Column('tag_id', db.Integer, db.ForeignKey('tags.id')),
                    )

class Device(db.Model):
    """An enrolled device.
    
          token (str): The hex string representing the Device Token, required to push with APNS.


          certificate_id (int): The ID of the certificate that this device is using to authenticate itself. May be null

    :table: devices
    """
    __tablename__ = 'devices'

    # Common attributes
    id = db.Column(db.Integer, primary_key=True)
    """id (int):"""
    udid = db.Column(db.String, index=True, nullable=True)
    """udid (str): Unique Device Identifier"""
    last_seen = db.Column(db.DateTime, nullable=True)
    """last_seen (datetime.datetime): When the device last contacted the MDM."""
    is_enrolled = db.Column(db.Boolean, default=False)
    """is_enrolled (bool): Whether the MDM should consider this device enrolled."""

    # APNS / Push
    topic = db.Column(db.String, nullable=True)
    """topic (str): The APNS topic the device is listening on."""
    push_magic = db.Column(db.String, nullable=True)
    """push_magic (str): The UUID that establishes a unique relationship between the device and the MDM."""
    # The APNS device token is stored in base64 format. Descriptors are added to handle this encoding and decoding
    # to bytes automatically.
    _token = db.Column(db.String, nullable=True)
    tokenupdate_at = db.Column(db.DateTime)

    # Table 5
    last_cloud_backup_date = db.Column(db.DateTime)
    awaiting_configuration = db.Column(db.Boolean)
    """awaiting_configuration (bool): True if device is waiting at Setup Assistant"""
    
    # Table 6
    itunes_store_account_is_active = db.Column(db.Boolean)
    """itunes_store_account_is_active (bool): the user is currently logged into an active iTunes Store account."""
    itunes_store_account_hash = db.Column(db.String)
    """itunes_store_account_hash (str): a hash of the iTunes Store account currently logged in."""

    # DeviceInformation : Table 7
    device_name = db.Column(db.String)  # Authenticate
    """device_name (str): Name of the device"""
    os_version = db.Column(db.String)  # Authenticate
    """os_version (str): The operating system version number."""
    build_version = db.Column(db.String)  # Authenticate
    """build_version (str): DeviceInformation BuildVersion"""
    model_name = db.Column(db.String)  # Authenticate
    """model_name (str): Longer name of the hardware model"""
    model = db.Column(db.String)  # Authenticate
    """model (str): Name of the hardware model"""
    product_name = db.Column(db.String)  # Authenticate
    """product_name (str): The base product name of the hardware"""
    serial_number = db.Column(db.String(64), index=True, nullable=True)  # Authenticate
    """serial_number (str): The hardware serial number"""
    device_capacity = db.Column(db.Float, nullable=True)
    """device_capacity (float): total capacity (base 1024 gigabytes)"""
    available_device_capacity = db.Column(db.Float, nullable=True)
    """device_available_capacity (float): available capacity (base 1024 gigabytes)"""
    battery_level = db.Column(db.Float, default=-1.0)
    """battery_level (float): battery level, between 0.0 and 1.0. -1.0 if information is not available."""
    cellular_technology = db.Column(db.Enum(CellularTechnology))
    """cellular_technology (CellularTechnology): cellular technology."""
    imei = db.Column(db.String)
    """imei (str): IMEI number (if device is GSM)."""
    meid = db.Column(db.String)
    """meid (str): MEID number (if device is CSMA)."""
    modem_firmware_version = db.Column(db.String)
    """modem_firmware_version (str): The baseband firmware version."""
    is_supervised = db.Column(db.Boolean)
    """is_supervised (bool): Device is supervised"""
    is_device_locator_service_enabled = db.Column(db.Boolean)
    """is_device_locator_service_enabled (bool): Find My iPhone/Mac enabled."""
    is_activation_lock_enabled = db.Column(db.Boolean)
    """is_activation_lock_enabled (bool): Device has Activation Lock enabled."""
    is_do_not_disturb_in_effect = db.Column(db.Boolean)
    """is_do_not_disturb_in_effect (bool): Device has DND enabled."""
    device_id = db.Column(db.String)  # ATV
    """device_id (str): Device ID (ATV)"""
    eas_device_identifier = db.Column(db.String)
    """eas_device_identifier (str): Exchange ActiveSync Identifier"""
    is_cloud_backup_enabled = db.Column(db.Boolean)
    """is_cloud_backup_enabled (bool): iCloud backup is enabled."""
    # TODO: OSUpdateSettings
    local_hostname = db.Column(db.String)
    """local_hostname (str): """
    hostname = db.Column(db.String)
    """hostname (str): """
    sip_enabled = db.Column(db.Boolean)
    """sip_enabled (bool): System Integrity Protection is enabled."""
    # TODO: ActiveManagedUsers
    is_mdm_lost_mode_enabled = db.Column(db.Boolean)
    """is_mdm_lost_mode_enabled (bool): MDM Lost mode is enabled."""
    maximum_resident_users = db.Column(db.Integer)
    """maximum_resident_users (int): Maximum number of users that can use Shared iPad."""

    # NetworkInfo : Table 9
    iccid = db.Column(db.String)
    """iccid (str): The ICC identifier for the SIM card."""
    bluetooth_mac = db.Column(db.String)
    """bluetooth_mac (str): The bluetooth MAC address"""
    wifi_mac = db.Column(db.String)
    """wifi_mac (str): The WiFi MAC address"""
    # TODO: EthernetMACs
    current_carrier_network = db.Column(db.String)
    """current_carrier_network (str): Name of the current carrier network."""
    sim_carrier_network = db.Column(db.String)
    """sim_carrier_network (str): Name of the home carrier network."""
    subscriber_carrier_network = db.Column(db.String)
    """subscriber_carrier_network (str): Name of the home carrier network (replaces sim_carrier_network)."""
    carrier_settings_version = db.Column(db.String)
    """carrier_settings_version (str): Version of the current carrier settings file."""
    phone_number = db.Column(db.String)
    """phone_number (str): Raw phone number without punctuation."""
    voice_roaming_enabled = db.Column(db.Boolean)
    """voice_roaming_enabled (bool): Voice Roaming is enabled in settings."""
    data_roaming_enabled = db.Column(db.Boolean)
    """data_roaming_enabled (bool): Data Roaming is enabled in settings."""
    is_roaming = db.Column(db.Boolean)
    """is_roaming (bool): The device is currently roaming."""
    personal_hotspot_enabled = db.Column(db.Boolean)
    """personal_hotspot_enabled (bool): Personal HotSpot is currently turned on."""
    subscriber_mcc = db.Column(db.String)
    """subscriber_mcc (str): Home Mobile Country Code (numeric)"""
    subscriber_mnc = db.Column(db.String)
    """subscriber_mnc (str): Home Mobile Network Code (numeric)"""
    current_mcc = db.Column(db.String)
    """current_mcc (str): Current Mobile Country Code (numeric)"""
    current_mnc = db.Column(db.String)
    """current_mnc (str): Current Mobile Network Code (numeric)"""

    # SecurityInfo
    # hardware_encryption_caps = db.Column(DBEnum(HardwareEncryptionCaps))
    passcode_present = db.Column(db.Boolean)
    """passcode_present (bool): Device has a passcode."""
    passcode_compliant = db.Column(db.Boolean)
    """passcode_compliant (bool): The passcode is compliant with all requirements (incl Exchange accounts)."""
    passcode_compliant_with_profiles = db.Column(db.Boolean)
    passcode_lock_grace_period_enforced = db.Column(db.Boolean)
    fde_enabled = db.Column(db.Boolean)
    fde_has_prk = db.Column(db.Boolean)
    fde_has_irk = db.Column(db.Boolean)
    fde_personal_recovery_key_cms = db.Column(db.LargeBinary)  # 10.13
    fde_personal_recovery_key_device_key = db.Column(db.String)  # 10.13
    firewall_enabled = db.Column(db.Boolean)
    """firewall_enabled (bool): Application firewall is enabled."""
    block_all_incoming = db.Column(db.Boolean)
    """block_all_incoming (bool): All incoming connections are blocked."""
    stealth_mode_enabled = db.Column(db.Boolean)
    """stealth_mode_enabled (bool): Stealth mode is enabled."""
    # TODO: Blocked Applications

    @hybrid_property
    def token(self):
        return self._token if self._token is None else base64.b64decode(self._token)

    @token.setter
    def token(self, value):
        self._token = base64.b64encode(value) if value is not None else None

    @property
    def hex_token(self):
        """Retrieve the device token in hex encoding, necessary for the APNS2 client."""
        if self._token is None:
            return self._token
        else:
            return hexlify(self.token).decode('utf8')

    # if null there are no outstanding push notifications. If this contains anything then dont attempt to deliver
    # another APNS push.
    last_push_at = db.Column(db.DateTime, nullable=True)
    """last_push_at (datetime.datetime): The datetime when the last push was sent to APNS for this device."""
    last_apns_id = db.Column(db.Integer, nullable=True)
    """last_apns_id (str): The UUID of the last apns command sent."""

    # if the time delta between last_push_at and last_seen is >= several days to a week,
    # this should count as a failed push, and potentially declare the device as dead.
    failed_push_count = db.Column(db.Integer, default=0, nullable=False)
    _unlock_token = db.Column(db.String(), name='unlock_token', nullable=True)

    certificate_id = db.Column(db.Integer, db.ForeignKey('certificates.id'))
    certificate = db.relationship('Certificate', backref='devices')

    tags = db.relationship(
        'Tag',
        secondary=device_tags,
        back_populates='devices'
    )

    @property
    def unlock_token(self):
        return self._unlock_token

    @unlock_token.setter
    def unlock_token(self, value):
        if isinstance(value, NSData):
            self._unlock_token = NSData.encode('base64')
        else:
            self._unlock_token = value

    @property
    def platform(self) -> Platform:
        if self.model_name in ['iMac', 'MacBook Pro', 'MacBook Air', 'Mac Pro']:  # TODO: obviously not sufficient
            return Platform.macOS
        elif self.model_name in ['iPhone', 'iPad']:
            return Platform.iOS
        else:
            return Platform.Unknown

    def __repr__(self):
        return '<Device ID=%r UDID=%r SerialNo=%r>' % (self.id, self.udid, self.serial_number)


device_group_devices = db.Table('device_group_devices', db.metadata,
                             db.Column('device_group_id', db.ForeignKey('device_groups.id'), primary_key=True),
                             db.Column('device_id', db.ForeignKey('devices.id'), primary_key=True),
                             )


class DeviceGroup(db.Model):
    __tablename__ = 'device_groups'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String, nullable=False)


class InstalledApplication(db.Model):
    """This model represents a single application that was returned as part of an ``InstalledApplicationList`` query.
    
    It is impossible to create a composite key to uniquely identify each row, therefore every time the device reports
    back we need to wipe all rows associated with a single device. The reason why a composite key won't work here is
    that macOS will often report the binary name and no identifier, version, or size (and sometimes iOS can do the
    inverse of that).
    
    :table: installed_applications
    """
    __tablename__ = 'installed_applications'

    id = db.Column(db.Integer, primary_key=True)
    """id (int): Identifier"""
    device_udid = db.Column(GUID, index=True, nullable=False)
    """device_udid (GUID): Unique device identifier"""
    device_id = db.Column(db.ForeignKey('devices.id'), nullable=True)
    """device_id (int): Parent relationship ID of the device"""
    device = db.relationship('Device', backref='installed_applications')
    """device (db.relationship): SQLAlchemy relationship to the device."""

    # Many of these can be empty, so there is no valid composite key
    bundle_identifier = db.Column(db.String, index=True)
    """bundle_identifier (str): The com.xxx.yyy bundle identifier for the application. May be empty."""
    version = db.Column(db.String, index=True)
    """version (str): The long version for the application. May be empty."""
    short_version = db.Column(db.String)
    """short_version (str): The short version for the application. May be empty."""
    name = db.Column(db.String)
    """name (str): The application name"""
    bundle_size = db.Column(db.BigInteger)
    """bundle_size (int): The application size"""
    dynamic_size = db.Column(db.BigInteger)
    """dynamic_size (int): The dynamic data size (for iOS containers)."""
    is_validated = db.Column(db.Boolean)
    """is_validated (bool):"""


class InstalledCertificate(db.Model):
    """This model represents a single installed certificate on an enrolled device as returned by the ``CertificateList``
    query.
    
    The response will usually include both certificates managed by profiles and certificates that were installed
    outside of a profile.
    
    :table: installed_certificates
    """
    __tablename__ = 'installed_certificates'

    id = db.Column(db.Integer, primary_key=True)
    """(int): Installed Certificate ID"""
    device_udid = db.Column(GUID, index=True, nullable=False)
    """(GUID): Unique Device Identifier"""
    device_id = db.Column(db.ForeignKey('devices.id'), nullable=True)
    """(int): Device foreign key ID."""
    device = db.relationship('Device', backref='installed_certificates')
    """(db.relationship): Device relationship"""
    x509_cn = db.Column(db.String)
    """(str): The X.509 Common Name of the certificate."""
    is_identity = db.Column(db.Boolean)
    """(bool): Is the certificate an identity certificate?"""
    der_data = db.Column(db.LargeBinary, nullable=False)
    """(bytes): The DER encoded certificate data."""
    fingerprint_sha256 = db.Column(db.String(64), nullable=False, index=True)
    """(str): SHA-256 fingerprint of the certificate."""


class InstalledProfile(db.Model):
    """This model represents a single installed profile on an enrolled device as returned by the ``ProfileList`` query.
    
    The response does not contain the entire contents of the profiles installed therefore the UUIDs returned are joined
    against our profiles table to ascertain whether profiles have been installed or not.
    
    :table: installed_profiles
    """
    __tablename__ = 'installed_profiles'

    id = db.Column(db.Integer, primary_key=True)
    """(int): Installed Profile ID"""
    device_udid = db.Column(GUID, index=True, nullable=False)
    """(GUID): Unique Device Identifier"""
    device_id = db.Column(db.ForeignKey('devices.id'), nullable=True)
    """(int): Device foreign key ID."""
    device = db.relationship('Device', backref='installed_profiles')
    """(db.relationship): Device relationship"""

    has_removal_password = db.Column(db.Boolean)
    """(bool): Does the installed profile have a removal password?"""
    is_encrypted = db.Column(db.Boolean)
    """(bool): Is the installed profile encrypted?"""

    payload_description = db.Column(db.String)
    """(str): Payload description (value of PayloadDescription)"""
    payload_display_name = db.Column(db.String)
    """(str): Payload display name"""
    payload_identifier = db.Column(db.String)
    payload_organization = db.Column(db.String)
    payload_removal_disallowed = db.Column(db.Boolean)
    payload_uuid = db.Column(GUID, index=True)
    # SignerCertificates
    


class CommandSequence(db.Model):
    """A command sequence represents a series of commands where all members must succeed in order for the sequence to
    succeed. I.E a single failure or timeout in the sequence stops the delivery of every other member.

    :table: command_sequences
    """
    __tablename__ = 'command_sequences'

    id = db.Column(db.Integer, primary_key=True)
    

class Command(db.Model):
    """The command model represents a single MDM command that should be, has been, or has failed to be delivered to
    a single enrolled device.
    
    :table: commands
    """
    __tablename__ = 'commands'

    id = db.Column(db.Integer, primary_key=True)
    """id (int): ID"""
    request_type = db.Column(db.String, nullable=False)  # string representation of our local command handler
    """request_type (str): The command RequestType attribute"""
    uuid = db.Column(GUID, index=True, unique=True, nullable=False)
    """uuid (GUID): Globally unique command UUID"""
    parameters = db.Column(MutableDict.as_mutable(JSONEncodedDict),
                        nullable=True)  # JSON add'l data as input to command builder
    """parameters (str): The parameters that were used when generating the command, serialized into JSON. Omitting the
            RequestType and CommandUUID attributes."""
    status = db.Column(db.String(1), index=True, nullable=False, default=CommandStatus.Queued.value)
    """status (CommandStatus): The status of the command."""
    queued_at = db.Column(db.DateTime, default=datetime.datetime.utcnow(), server_default=db.text('CURRENT_TIMESTAMP'))
    """queued_at (datetime.datetime): The datetime (utc) of when the command was created. Defaults to UTC now"""
    sent_at = db.Column(db.DateTime, nullable=True)
    """sent_at (datetime.datetime): The datetime (utc) of when the command was delivered to the client."""
    acknowledged_at = db.Column(db.DateTime, nullable=True)
    """acknowledged_at (datetime.datetime): The datetime (utc) of when the Acknowledged, Error or NotNow response was
        returned."""
    # command must only be sent after this date
    after = db.Column(db.DateTime, nullable=True)
    """after (datetime.datetime): If not null, the command must not be sent until this datetime is in the past."""

    # number of retries remaining until dead
    ttl = db.Column(db.Integer, nullable=False, default=5)
    """ttl (int): The number of retries remaining until the command will be dead/expired."""

    device_id = db.Column(db.ForeignKey('devices.id'), nullable=True)
    """device_id (int): The device ID on the devices table."""
    device = db.relationship('Device', backref='commands')
    """device (Device): The instance of the related device."""

    # device_user_id = db.Column(ForeignKey('device_users.id'), nullable=True)
    # device_user = relationship('DeviceUser', backref='commands')
    @classmethod
    def from_model(cls, cmd: commands.Command):
        c = cls()
        c.request_type = cmd.request_type
        c.uuid = cmd.uuid
        c.parameters = cmd.parameters

        return c

    @classmethod
    def find_by_uuid(cls, uuid):
        """Find and return an instance of the Command model matching the given UUID string.
        
        Args:
              uuid (str): The command UUID
              
        Returns:
              Command: Instance of the command, if any
        """
        return cls.query.filter(cls.uuid == uuid).one()

    @classmethod
    def get_next_device_command(cls, device):
        # d == d AND (q_status == Q OR (q_status == R AND result == 'NotNow'))
        return cls.query.filter(db.and_(
                cls.device == device,
                cls.status == CommandStatus.Queued.value)).order_by(cls.id).first()

    def __repr__(self):
        return '<Command ID=%r UUID=%r qstatus=%r>' % (self.id, self.uuid, self.status)


class App(db.Model):
    __tablename__ = 'apps'

    id = db.Column(db.Integer, primary_key=True)

    filename = db.Column(db.String, nullable=False, unique=True)
    filesize = db.Column(db.Integer, nullable=False)

    md5_hash = db.Column(db.String(32), nullable=False)  # MD5 hash of the entire file

    # MDM clients support a chunked method of retrival of the download file
    # presumably to best support OTA download of large updates. These fields
    # are in support of that mechanism
    md5_chunk_size = db.Column(db.Integer, nullable=False)
    md5_chunk_hashes = db.Column(db.Text, nullable=True)  # colon (:) separated list of MD5 chunk hashes

    bundle_ids_json = db.Column(MutableList.as_mutable(JSONEncodedDict), nullable=True)
    pkg_ids_json = db.Column(MutableList.as_mutable(JSONEncodedDict), nullable=True)

    def path_format(self):
        return '%010d.dat' % self.id

    def __repr__(self):
        return '<App ID=%r Filename=%r>' % (self.id, self.filename)


# class DEPConfig(db.Model):
#     __tablename__ = 'dep_config'
#
#     id = db.Column(db.Integer, primary_key=True)
#
#     # certificate for PKI of server token
#     certificate_id = db.Column(ForeignKey('certificates.id'))
#     certificate = relationship('Certificate', backref='dep_configs')
#
#     server_token = db.Column(MutableDict.as_mutable(JSONEncodedDict), nullable=True)
#     auth_session_token = db.Column(db.String, nullable=True)
#
#     initial_fetch_complete = db.Column(Boolean, nullable=False, default=False)
#     next_check = db.Column(db.DateTime(timezone=False), nullable=True)
#     device_cursor = db.Column(db.String)
#     device_cursor_recevied = db.Column(db.DateTime(timezone=False), nullable=True)  # shouldn't use if more than 7 days old
#
#     url_base = db.Column(db.String, nullable=True)  # testing server environment if used
#
#     def last_check_delta(self):
#         if self.next_check:
#             return str(self.next_check - datetime.datetime.utcnow())
#         else:
#             return ''

#
# class DEPProfile(db.Model):
#     __tablename__ = 'dep_profile'
#
#     id = db.Column(db.Integer, primary_key=True)
#
#     mdm_config_id = db.Column(ForeignKey('mdm_config.id'), nullable=False)
#     mdm_config = relationship('MDMConfig', backref='dep_profiles')
#
#     dep_config_id = db.Column(ForeignKey('dep_config.id'), nullable=False)
#     dep_config = relationship('DEPConfig', backref='dep_profiles')
#
#     # DEP-assigned UUID for this DEP profile
#     uuid = db.Column(db.db.String(36), index=True, nullable=True)  # should be unique but it's assigned to us so can't be null
#
#     profile_data = db.Column(MutableDict.as_mutable(JSONEncodedDict), nullable=False)
#
#     def profile_name(self):
#         return self.profile_data['profile_name']


class User(db.Model):
    __tablename__ = 'users'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String)
    fullname = db.Column(db.String)
    password = db.Column(db.String)


class DeviceUser(db.Model):
    """
    This model represents a managed user from the standpoint of the MDM.
    It exists to support the macOS user channel extension.

    :table: device_users

    Attributes:
          user_id (GUID): Local user's GUID, or network user's GUID from Open Directory Record.
    """
    __tablename__ = 'device_users'

    id = db.Column(db.Integer, primary_key=True)

    udid = db.Column(GUID, nullable=False)
    user_id = db.Column(GUID, nullable=False)
    long_name = db.Column(db.String)
    short_name = db.Column(db.String)
    need_sync_response = db.Column(db.Boolean)  # This is kind of transitive but added anyway.
    user_configuration = db.Column(db.Boolean)
    digest_challenge = db.Column(db.String)
    auth_token = db.Column(db.String)


class Organization(db.Model):
    """The MDM home organization configuration.
    
    These attributes are used as the defaults for several other services where an org name is required.
    
    :table: organizations
    """
    __tablename__ = 'organizations'

    id = db.Column(db.Integer, primary_key=True)
    """id (int): ID"""
    name = db.Column(db.String)
    """name (string): Name"""
    payload_prefix = db.Column(db.String)
    """payload_prefix (string): The reverse-dns style prefix to use for all generated profiles."""

    # http://www.ietf.org/rfc/rfc5280.txt
    # maximum string lengths are well defined by this RFC and this schema follows those recommendations
    # this x.509 name is used in the subject of the internal CA and issued certificates
    x509_ou = db.Column(db.String(32))
    """x509_ou (string): The x.509 Organizational Unit for generating certificates."""
    x509_o = db.Column(db.String(64))
    """x509_o (string): The x.509 Organization for generating certificates."""
    x509_st = db.Column(db.String(128))
    """x509_st (string): The x.509 State for generating certificates."""
    x509_c = db.Column(db.String(2))
    """x509_c (string): The 2 letter x.509 country code for generating certificates. """


class AppSourceType(Enum):
    S3 = 'S3'
    Munki = 'Munki'


class ApplicationSource(db.Model):
    """This table holds rows indicating sources that may referenced in ``InstallApplication`` commands.
    
    The MDM may require write access to create application manifests from existing items.
    
    :table: application_sources
    """
    __tablename__ = 'application_sources'

    id = db.Column(db.Integer, primary_key=True)
    """id (db.Integer): ID"""
    name = db.Column(db.String)
    """name (db.String): A short, descriptive name for the source. Only used in display."""
    source_type = db.Column(db.Enum(AppSourceType), default=AppSourceType.Munki)
    """source_type (AppSourceType): The application source type."""

    endpoint = db.Column(db.String)
    """endpoint (db.String): The hostname for object storage or URI for read-only munki repositories."""
    mount_uri = db.Column(db.String)
    """mount_uri (db.String): The R/W mount URI for munki repositories only."""
    use_ssl = db.Column(db.Boolean)
    """use_ssl (Boolean): Use SSL when connecting to endpoint. Used when endpoint is host only."""

    # For S3 / Minio
    access_key = db.Column(db.String)
    """access_key (db.String): The access key for S3 / Minio that uniquely identifies this client."""
    secret_key = db.Column(db.String)
    """secret_key (db.String): The secret key for S3 / Minio that authenticates this client."""
    bucket = db.Column(db.String)
    """bucket (db.String): The bucket name that holds installation packages."""
    

class SCEPConfig(db.Model):
    """This table holds a single row containing information used to generate the SCEP enrollment profile.
    
    :table: scep_config
    
    See Also:
          - `https://tools.ietf.org/html/rfc3280.html`_.
    """
    __tablename__ = 'scep_config'

    id = db.Column(db.Integer, primary_key=True)
    url = db.Column(db.String, nullable=False)

    challenge_enabled = db.Column(db.Boolean, default=False)
    challenge = db.Column(db.String)
    ca_fingerprint = db.Column(db.String)
    subject = db.Column(db.String, nullable=False)  # eg. O=x/OU=y/CN=z
    key_size = db.Column(db.Integer, default=2048, nullable=False)
    key_type = db.Column(db.String, default='RSA', nullable=False)
    key_usage = db.Column(db.Enum(KeyUsage), default=KeyUsage.All)

    retries = db.Column(db.Integer, default=3, nullable=False)
    retry_delay = db.Column(db.Integer, default=10, nullable=False)
    certificate_renewal_time_interval = db.Column(db.Integer, default=14, nullable=False)


class SubjectAlternativeNameType(Enum):
    """Types of SubjectAlternativeNames that can be added using cryptography SAN extension.
    
    See Also:
          - `https://tools.ietf.org/html/rfc3280.html`_.
    """
    
    RFC822Name = 'RFC822Name'
    """E-mail address, see: https://tools.ietf.org/html/rfc822"""
    
    DNSName = 'DNSName'
    UniformResourceIdentifier = 'UniformResourceIdentifier'
    DirectoryName = 'DirectoryName'
    RegisteredID = 'RegisteredID'
    IPAddress = 'IPAddress'
    OtherName = 'OtherName'
    # TODO: ntPrincipal


class SubjectAlternativeName(db.Model):
    """This table holds SANs included in the SCEP enrollment request.
    
    :table: subject_alternative_names
    """
    __tablename__ = 'subject_alternative_names'

    id = db.Column(db.Integer, primary_key=True)
    discriminator = db.Column(db.Enum(SubjectAlternativeNameType), nullable=False)

    str_value = db.Column(db.String)
    octet_value = db.Column(db.LargeBinary)  # For IPAddress
    

class Tag(db.Model):
    """This table holds tags, which are categories that are many-to-many and polymorphic to different types of
    objects."""
    __tablename__ = 'tags'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String, nullable=False)
    color = db.Column(db.String(6), default='888888')

    devices = db.relationship(
        "Device",
        secondary=device_tags,
        back_populates="tags",
    )

    # profiles = db.relationship(
    #     "Tag",
    #     secondary=profile_tags,
    #     back_populates="tags",
    # )

